void *ptr;
ptr = &n
int n = 42;
void *ptr = &n;  % 포인터 ptr이 n의 주소를 가리킴

int* ptr = &n;  % 포인터 ptr이 n의 주소를 가리킴, int형 포인터로 선언

포인터 한 문제는 어렵다.
이론 문제 3개
이차원 배열은 하나 나옴, 매우 쉬움
재귀 함수 2개
함수 호출하는거

&연산자 : 주고 연산자 
*연산자 : 역참조 연산자, 값을 가져옴

32bit 컴퓨터 내에서 포인터 형태는 4바이트이다.
%p는 메모리 주소를 16진수로 표현하는 서식 지정자이다

\o 이랑 void* 은 다르다. null

ptr = arr 하면 200번지 주소가 들어감
ptr = *arr;

*(ptr+2)

(short*)ptr + 2; % ptr이 가리키는 주소에서 2바이트를 더한 주소를 가리킴
*((short*)ptr + 1;) % ptr이 가리키는 주소에서 1바이트를 더한 주소의 값을 가져옴

포인터 배열 배열의 이름 = 배열의 시작 주소를 가리키는 상수 포인터
+,-,++,-- 포인터 사용 가능, 배열은 +,-만 사용 가능
int a =10;
a+1 = 10
a++; = 11

%p 는 포인터의 주소를 출력하는 서식 지정자이다. 16진수

int a[3] = {9, 99, 999};
int *p = a;
(%d)printf("*p+1, *p++, *++p, ++*p, *p+=1");
(*p+1) = 10;
(*p++) =  9;(10)
(*++p) = 999
(++*p) = 1000
(*p+=1) = 1001